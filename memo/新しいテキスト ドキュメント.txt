
・設定ファイルはツリー構造をなす
・JSON 的な構造だが、本物の JavaScript オブジェクトであり、関数呼び出しなど必要であれば自由に記述できる（JC 社向け案件でやったのと同様）

・「乱数埋め係」を設ける
	・ツリーをなめ、「乱数が必要だが指定が欠けている」個所に、デフォルトの乱数生成器を生成して埋めていく
	・乱数生成器の生成に使う乱数の種、およびどんなアルゴリズムの生成器を生成するかは、埋め係の設定による
	
	・乱数埋め係は普通設定のルートに定義するが、任意のノードに定義することができ、その配下の乱数埋めを担当する
		・乱数埋め係自体も種を必要とするが、その種は上位の埋め係、もしくはシステム全体のデフォルト（時刻とか、コマンドライン引数）から供給される
	・埋め係は設定ツリーを一意な順序でたどる
		・配列は先頭から、オブジェクトはキーの辞書順とか
		・これにより、埋め係の初期状態とツリーの内容が同じなら同じ乱数が供給されることが保証される
		
	・乱数埋めのニーヅ
		・種さえ決まればよい
		・乱数列そのもの（もしくは数列を生成するアルゴリズム）がほしい
		・ランダムな値が 1 つほしい
		
		
	・「乱数が必要」

・乱数埋め係が動作できるよう、設定ファイルは JavaScript の配列・オブジェクトに全て展開される必要がある
	・この制約はきついか？
	・つまり、
		{
			type: lrtb,
			tileSize: [32, 32],
		}
	　みたいな連想配列として記述する必要がある
	・最終的に展開されるなら関数を使うのはありだが…
	　たとえば上記を lrtb([32, 32]) と書けるようにする
	　
	・設定ファイルへの対応コストが大きそうなのが懸念
		・次の 2 つが必要になる：
			・本体側で上記のオブジェクトを解釈して Divider を生成する
			・JS 側で関数 lrtb() を提供する（もしくは本体側が提供する）

	・この方法のメリットは乱数埋め処理が JS 側で完結すること
		・設定ファイルの読み込み → 乱数補完 → 保存の流れがシンプルに行える
	


